label = country
), colour = "black") +
coord_equal() +
scale_fill_distiller(palette = "PRGn",
na.value = "light grey",
limits = c(2, 8)) +
theme(
axis.text = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
panel.border = element_rect(colour = "black", fill=NA, size = 1.5),
panel.grid = element_blank(),
panel.background = element_rect(fill = "light blue"),
plot.title = element_text(hjust = 0.5, size = 16, face = "bold.italic" )) +
ggtitle("Happiness Scores around the World") +
theme(legend.position= "bottom")
happ_map_plot
# Interactive Map
# ggplotly(happ_map_plot, tooltip = c("label", "fill"))
# Place all attribute scores on one variable for plotting
happ_attr2019 <- happ_2019 %>%
filter(year == 2019) %>%
pivot_longer(cols = gdp_per_capita:perceptions_of_corruption,
names_to = "attr",
values_to = "attr_score")
require(wbstats)
# Retrieve population estimates of countries in the world
pop_ests2018 <- wb(indicator = "SP.POP.TOTL", startdate = 2018, enddate = 2019)
pop_ests2018 <- pop_ests2018 %>%
select(country, value) %>%
rename(pop_total = value)
# Make country names consistent with population data
# setdiff(happiness_attr2019$country,pop_ests2018$country)
happ_attr2019$country <-
dplyr::recode(
happ_attr2019$country,
"Taiwan" = "China",
"Slovakia" = "Slovak Republic",
"Trinidad & Tobago" = "Trinidad and Tobago",
"South Korea" = "Korea, Rep.",
"Northern Cyprus" = "Cyprus",
"Russia" = "Russian Federation",
"Hong Kong" = "Hong Kong SAR, China",
"Kyrgyzstan" = "Kyrgyz Republic",
"Macedonia" = "North Macedonia",
"Ivory Coast" = "Cote d'Ivoire",
"Congo (Brazzaville)" = "Congo, Rep.",
"Laos" = "Lao PDR",
"Venezuela" = "Venezuela, RB",
"Palestinian Territories" = "West Bank and Gaza",
"Iran" = "Iran, Islamic Rep.",
"Congo (Kinshasa)" = "Congo, Dem. Rep.",
"Swaziland" = "Swaziland",
"Gambia" = "Gambia",
"Egypt" = "Egypt, Arab Rep.",
"Syria" = "Syrian Arab Republic",
"Yemen" = "Yemen, Rep.")
# Filter only countries in happiness dataset
happ_attr2019 <-
full_join(happ_attr2019, pop_ests2018, by = "country") %>%
filter(!is.na(overall_rank))
# Compute average attribute scores for each attribute
attr_scores2019 <- happ_attr2019 %>%
group_by(attr) %>%
summarise(mean_attr_score = mean(attr_score))
# Insert average attribute scores in df
happ_attr2019 <- full_join(happ_attr2019, attr_scores2019, by = "attr")
happ_attr2019_plot <- ggplot(data = happ_attr2019,
aes(x = 1:nrow(happ_attr2019), # x: number of rows in dataset
y = attr_score)) +
geom_point(aes(
colour = region,
alpha = 0.8,
size = pop_total,
label = country
)) +
scale_colour_brewer(palette = "Paired") +
# Remove x-axis title, lable and ticks
theme(axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank()) +
facet_wrap(~ attr,
scales = "free_y", # rescale each attribute score
ncol = 3,
nrow = 2,
strip.position = "bottom"
) +
geom_line(aes(y = mean_attr_score, # Add average attribute
x = 1:nrow(happ_attr2019),
group = attr),
colour = "black",
alpha = 0.7,
linetype = "dashed") +
labs(y = "Attribute Scores") +
theme(legend.position = "none",
panel.background = element_rect(fill = "light grey")
)
happ_attr2019_plot
# Interactive map
# ggplotly(happ_attr2019_plot, tooltip = c("colour","label", "y", "size"))
data2015 <- read.csv(here::here("Data/2015.csv"))
data2016 <- read.csv(here::here("Data/2016.csv"))
data2017 <- read.csv(here::here("Data/2017.csv"))
data2018 <- read.csv(here::here("Data/2018.csv"))
data2019 <- read.csv(here::here("Data/2019.csv"))
GDP<-read_csv("Data/API_NY.GDP.MKTP.CD_DS2_en_csv_v2_1120928.csv",skip=4)
CPI<-read_csv("Data/API_FP.CPI.TOTL.ZG_DS2_en_csv_v2_1120899.csv", skip = 4)
Population<- read_csv("Data/API_SP.POP.TOTL_DS2_en_csv_v2_1120881.csv", skip = 4)
world_map <-ne_countries(returnclass = "sf")
model2015 <- lm(as.formula(paste('`',
colnames(data2015)[4], "`~`",
paste(colnames(data2015)[c(6, 7, 8, 9, 10, 11, 12)], collapse = "`+`"),
'`',
sep = ""
)), data = data2015)
model2016 <- lm(as.formula(paste('`',
colnames(data2016)[4], "`~`",
paste(colnames(data2016)[c( 7, 8, 9, 10, 11, 12,13)], collapse = "`+`"),
'`',
sep = ""
)), data = data2016)
model2017 <- lm(as.formula(paste('`',
colnames(data2017)[3], "`~`",
paste(colnames(data2017)[c(5,6, 7, 8, 9, 10, 11)], collapse = "`+`"),
'`',
sep = ""
)), data = data2017)
c_table <- summary(model2015)
rownames(c_table$coefficients) = c_table$coefficients %>%
rownames() %>%
stringr::str_remove_all('`')
c_table$coefficients %>%
knitr::kable(
caption = "Linear regression model for happiness scores in 2015") %>%
kableExtra::kable_styling(latex_options = "striped")
R15<-summary(model2015)$r.squared
R16<-summary(model2016)$r.squared
R17<-summary(model2017)$r.squared
x<-data.frame(R15,R16,R17)
names(x)[1] <- "2015"
names(x)[2] <- "2016"
names(x)[3] <- "2017"
x%>%kable(caption = ' R Squared in 2015-2017') %>%
kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
temp <-data2015 %>%
dplyr::select(1,`Happiness Score` = Happiness.Score) %>%
mutate(year = 2015)
data2016 %>%
dplyr::select(1,`Happiness Score` = Happiness.Score) %>%
mutate(year = 2016) %>%
rbind(temp) -> temp
data2017%>%
dplyr::select(1, `Happiness Score` = Happiness.Score) %>%
mutate(year = 2017) %>%
rbind(temp) -> temp
data2018 %>%
dplyr::select(Country = `Country.or.region`, `Happiness Score` = Score) %>%
mutate(year = 2018) %>%
rbind(temp) -> temp
data2019 %>%
dplyr::select(Country = `Country.or.region`, `Happiness Score` = Score) %>%
mutate(year = 2019) %>%
rbind(temp) -> temp
happy_score<- temp
Population %>%
dplyr::select(Country = `Country Name`, `2015`:`2019`) %>%
gather(key = 'year', value = 'population', `2015`:`2019`) %>%
mutate(year = as.numeric(year)) %>%
right_join(happy_score) -> happy_score
GDP %>%
dplyr::select(Country = `Country Name`, `2015`:`2019`) %>%
gather(key = 'year', value = 'gdp', `2015`:`2019`) %>%
mutate(year = as.numeric(year)) %>%
right_join(happy_score) -> happy_score
CPI %>%
dplyr::select(Country = `Country Name`, `2015`:`2019`) %>%
gather(key = 'year', value = 'cpi', `2015`:`2019`) %>%
mutate(year = as.numeric(year)) %>%
right_join(happy_score) -> happy_score
world_map$area = st_area(world_map) %>% as.numeric()
as_tibble(world_map) %>%
dplyr::select(area, name) %>%
right_join(happy_score, by = c('name' = 'Country')) -> happy_score
happy_score<-happy_score%>% drop_na()
head(happy_score)%>%kable(caption = 'A clean dataset with Happiness Score')%>%
kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
model <- lm(log(`Happiness Score`)~log(area)+cpi+log(gdp)+log(population), data=happy_score)
relImportance<-model%>%relaimpo::calc.relimp(type="lmg",rela=TRUE)
#tibble('R^2' =relImportance$R2*100 , 'log(gpd)' = relImportance$lmg[3]*100,'log(population)' = relImportance$lmg[4]*100,'log(cpi)' = relImportance$lmg[2]*100,'log(area)' = relImportance$lmg[1]*100)%>%
#pivot_longer(cols = c('R^2', 'log(gpd)','log(population)','log(cpi)','log(area)'), names_to = "Relative importance",values_to = "Important(%)") %>%
#kable(caption = 'Variable importance in happiness score') %>%
#kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = "left")
data.frame(name = c('log(area)', 'cpi', 'log(gdp)', 'log(population)'), lmg = relImportance@lmg) %>%
ggplot()+
geom_bar(aes(name,lmg), stat = "identity") +
ylab('% of R^2') +
xlab(paste0('R^2 = ', round(relImportance@R2, digits = 4), ', metrics are normalized to sum 100%')) +
ggtitle("Relative importance for log(Happiness Score)\nMethod LMG")
as.table(car::vif(model))%>%
kable(caption = 'VIF procedures for checking multicollinearity with each predictors') %>%
kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = "left")
ggpairs(data=happy_score[,-c(2,3)],
main="Happiness Score Scatter Matrix")
h15 = read_csv("Data/2015.csv")
h16 = read_csv("Data/2016.csv")
h17 = read_csv("Data/2017.csv")
h18 = read_csv("Data/2018.csv")
h18$`Perceptions of corruption` = as.numeric(h18$`Perceptions of corruption`)
h19 = read_csv("Data/2019.csv")
library(rnaturalearth)
library(sf)
world_map = ne_countries(returnclass = 'sf')
gdp = read_csv("Data/API_NY.GDP.MKTP.CD_DS2_en_csv_v2_1120928.csv", skip = 4)
cpi = read_csv("Data/API_FP.CPI.TOTL.ZG_DS2_en_csv_v2_1120899.csv", skip = 4)
population = read_csv("Data/API_SP.POP.TOTL_DS2_en_csv_v2_1120881.csv", skip = 4)
temp = h15 %>%
dplyr::select(Country, `Happiness Score`) %>%
mutate(year = 2015)
h16 %>%
dplyr::select(Country, `Happiness Score`) %>%
mutate(year = 2016) %>%
rbind(temp) -> temp
h17 %>%
dplyr::select(Country, `Happiness Score` = Happiness.Score) %>%
mutate(year = 2017) %>%
rbind(temp) -> temp
h18 %>%
dplyr::select(Country = `Country or region`, `Happiness Score` = Score) %>%
mutate(year = 2018) %>%
rbind(temp) -> temp
h19 %>%
dplyr::select(Country = `Country or region`, `Happiness Score` = Score) %>%
mutate(year = 2019) %>%
rbind(temp) -> temp
hs = temp
population %>%
dplyr::select(Country = `Country Name`, `2015`:`2019`) %>%
gather(key = 'year', value = 'population', `2015`:`2019`) %>%
mutate(year = as.numeric(year)) %>%
right_join(hs) -> hs
gdp %>%
dplyr::select(Country = `Country Name`, `2015`:`2019`) %>%
gather(key = 'year', value = 'gdp', `2015`:`2019`) %>%
mutate(year = as.numeric(year)) %>%
right_join(hs) -> hs
cpi %>%
dplyr::select(Country = `Country Name`, `2015`:`2019`) %>%
gather(key = 'year', value = 'cpi', `2015`:`2019`) %>%
mutate(year = as.numeric(year)) %>%
right_join(hs) -> hs
world_map$area = st_area(world_map) %>% as.numeric()
as_tibble(world_map) %>%
dplyr::select(area, name) %>%
right_join(hs, by = c('name' = 'Country')) -> hs
nona_hs = na.omit(hs)
nona_hs = nona_hs %>%
mutate(log_score = log(`Happiness Score`), log_gdp = log(gdp), log_area = log(area), log_population = log(population)) %>%
dplyr::select(log_score:log_population, name, year, cpi)
lm(log_score~cpi+log_gdp+log_population+log_area,data=nona_hs) %>%
summary() -> lm_sum
rownames(lm_sum$coefficients) = lm_sum$coefficients %>%
rownames() %>%
stringr::str_remove_all('`')
lm_sum$coefficients %>%
knitr::kable('latex',
digits = 4,
booktabs = TRUE,
caption = "Linear regression model for happiness scores. The $R^2$ of this model is 0.7264.") %>%
kableExtra::kable_styling(latex_options = "striped")
world_map$not_included = is.na(sapply(world_map$name, match, table = hs$name))
ggplot()+
geom_sf(data = world_map, aes(fill = not_included))+
ggtitle("World map of countries that are not included in our dataset") +
theme_bw()+
theme(legend.position = 'bottom') +
labs(fill = "Not included")
library(ggrepel)
mod = lm(log_score~cpi+log_gdp+log_population+log_area,data=nona_hs)
mod_detail = broom::augment(mod, data = nona_hs)
p1 = ggplot(mod_detail) +
geom_point(aes(.fitted, .resid)) +
geom_smooth(aes(.fitted, .resid))
p2 = ggplot(mod_detail) +
geom_qq(aes(sample = .resid)) +
geom_qq_line(aes(sample = .resid))
p3 = ggplot(mod_detail) +
geom_point(aes(.fitted, .cooksd)) +
geom_text_repel(data = filter(mod_detail, .cooksd>0.0083), aes(.fitted, .cooksd, label = paste0(name,',',year)), col = 'red') +
geom_point(data = filter(mod_detail, .cooksd>0.0083), aes(.fitted, .cooksd), col="blue")
library(gridExtra)
grid.arrange(arrangeGrob(p1,p2, ncol=2),
arrangeGrob(p3, ncol=1, nrow=1), top = "Regression diagnostics\n Top left: Residuals vs Fitted. Top right: Normal QQ plot. Bottom:  Cooks distances vs Fitted.", heights=c(1,2))
p1 = ggplot()+
geom_sf(data = world_map, aes(fill = name %in% c('Suriname', 'Angola', 'Botswana', 'Sudan', 'Gabon', 'Sierra Leone', 'Togo', 'Burundi'))) +
theme_bw()+
theme(legend.position = "bottom") +
labs(fill = 'With influential points')
p2 = ggplot(mod_detail) +
geom_point(aes(log_gdp,.fitted)) +
geom_point(data = filter(mod_detail, name %in% c('Suriname', 'Angola', 'Botswana', 'Sudan', 'Gabon', 'Sierra Leone', 'Togo', 'Burundi')), aes(log_gdp,.fitted),col="red")
p3 = ggplot(mod_detail) +
geom_point(aes(cpi,.fitted)) +
geom_point(data = filter(mod_detail, name %in% c('Suriname', 'Angola', 'Botswana', 'Sudan', 'Gabon', 'Sierra Leone', 'Togo', 'Burundi')), aes(cpi,.fitted),col="red")
p4 = ggplot(mod_detail) +
geom_point(aes(log_population,.fitted)) +
geom_point(data = filter(mod_detail, name %in% c('Suriname', 'Angola', 'Botswana', 'Sudan', 'Gabon', 'Sierra Leone', 'Togo', 'Burundi')), aes(log_population,.fitted),col="red")
p5 = ggplot(mod_detail) +
geom_point(aes(log_area,.fitted)) +
geom_point(data = filter(mod_detail, name %in% c('Suriname', 'Angola', 'Botswana', 'Sudan', 'Gabon', 'Sierra Leone', 'Togo', 'Burundi')), aes(log_area,.fitted),col="red")
grid.arrange(p1, arrangeGrob(p2, p3, p4,p5, ncol=2), top = "Diagnostics for influential data points\n Top: World map of countries with influential data points. \n Bottom: Scatter plots of fitted value against each regressor. Red dots represent the influential data points.", ncol=1, heights =c(2,1))
knitr::opts_chunk$set(echo = FALSE, cache=TRUE, messages=FALSE, warning=FALSE)
happ_attr2019_plot <- ggplot(data = happ_attr2019,
aes(x = 1:nrow(happ_attr2019), # x: number of rows in dataset
y = attr_score)) +
geom_point(aes(
colour = region,
alpha = 0.8,
size = pop_total,
label = country,
position = "jitter"
)) +
scale_colour_brewer(palette = "Paired") +
# Remove x-axis title, lable and ticks
theme(axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank()) +
facet_wrap(~ attr,
scales = "free_y", # rescale each attribute score
ncol = 3,
nrow = 2,
strip.position = "bottom"
) +
geom_line(aes(y = mean_attr_score, # Add average attribute
x = 1:nrow(happ_attr2019),
group = attr),
colour = "black",
alpha = 0.7,
linetype = "dashed") +
labs(y = "Attribute Scores") +
theme(legend.position = "none",
panel.background = element_rect(fill = "light grey")
)
knitr::opts_chunk$set(echo = FALSE, cache=TRUE, messages=FALSE, warning=FALSE)
library(ggplot2)
library(here)
library(janitor)
library(lubridate)
library(maps)
library(plotly)
library(tidyverse)
require(wbstats)
happ_2015 <- read.csv(here::here("Data/2015.csv")) # To extract region info
happ_2019 <- read.csv(here::here("Data/2019.csv"))
happ_2019 <- happ_2019 %>%
mutate(year = year(ymd("2019-12-31"))) %>%
rename(Country = Country.or.region)
# Extract Countries and Regions from 2015 df
ctry_region <- happ_2015 %>%
select(Country, Region)
# Find countries that do not have a region
# setdiff(happ_2019$Country, ctry_region$Country)
ctry_region$Country <-
recode(
ctry_region$Country,
"Trinidad and Tobago" = "Trinidad & Tobago",
"North Cyprus" = "Northern Cyprus",
"Macedonia" = "North Macedonia",
"Somaliland region" = "Somalia",
"Sudan" = "South Sudan")
# Insert regions to NA regions
ctry_region <- ctry_region %>%
add_row(Country = "Namibia", Region = "Sub-Saharan Africa") %>%
add_row(Country = "Gambia", Region = "Sub-Saharan Africa") %>%
add_row(Country = "South Sudan", Region = "Sub-Saharan Africa") %>%
mutate(Region = as.factor(Region))
# Include regions in df
# Clean names
happ_2019 <- full_join(happ_2019, ctry_region, by = "Country") %>%
clean_names()
require(maps)
map_world <- map_data("world")
# Find conflicting country names
setdiff(happ_2019$country, map_world$region)
# Create new df for map
happ_map <- happ_2019
# setdiff(happ_2019$country, map_world$region)
# Solve conflicting names
happ_map$country <-
recode(
happ_map$country,
"United Kingdom" = "UK",
"United States" = "USA",
"Trinidad & Tobago" = "Trinidad",
"Northern Cyprus" = "Cyprus",
"Hong Kong" = "China",
"North Macedonia" = "Macedonia",
"Palestinian Territories" = "Palestine",
"Congo (Brazzaville)" = "Republic of Congo",
"Congo (Kinshasa)" = "Democratic Republic of the Congo")
# Join map and happiness data
map_combined <-
left_join(map_world, happ_map, by = c('region' = 'country')) %>%
rename(country = "region")
happ_map_plot <- ggplot(data = map_combined) +
geom_polygon(aes(
x = long,
y = lat,
group = group,
fill = score,
label = country
), colour = "black") +
coord_equal() +
scale_fill_distiller(palette = "PRGn",
na.value = "light grey",
limits = c(2, 8)) +
theme(
axis.text = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
panel.border = element_rect(colour = "black", fill=NA, size = 1.5),
panel.grid = element_blank(),
panel.background = element_rect(fill = "light blue"),
plot.title = element_text(hjust = 0.5, size = 16, face = "bold.italic" )) +
ggtitle("Happiness Scores around the World") +
theme(legend.position= "bottom")
happ_map_plot
# Interactive Map
# ggplotly(happ_map_plot, tooltip = c("label", "fill"))
# Place all attribute scores on one variable for plotting
happ_attr2019 <- happ_2019 %>%
filter(year == 2019) %>%
pivot_longer(cols = gdp_per_capita:perceptions_of_corruption,
names_to = "attr",
values_to = "attr_score")
require(wbstats)
# Retrieve population estimates of countries in the world
pop_ests2018 <- wb(indicator = "SP.POP.TOTL", startdate = 2018, enddate = 2019)
pop_ests2018 <- pop_ests2018 %>%
select(country, value) %>%
rename(pop_total = value)
# Make country names consistent with population data
# setdiff(happiness_attr2019$country,pop_ests2018$country)
happ_attr2019$country <-
recode(
happ_attr2019$country,
"Taiwan" = "China",
"Slovakia" = "Slovak Republic",
"Trinidad & Tobago" = "Trinidad and Tobago",
"South Korea" = "Korea, Rep.",
"Northern Cyprus" = "Cyprus",
"Russia" = "Russian Federation",
"Hong Kong" = "Hong Kong SAR, China",
"Kyrgyzstan" = "Kyrgyz Republic",
"Macedonia" = "North Macedonia",
"Ivory Coast" = "Cote d'Ivoire",
"Congo (Brazzaville)" = "Congo, Rep.",
"Laos" = "Lao PDR",
"Venezuela" = "Venezuela, RB",
"Palestinian Territories" = "West Bank and Gaza",
"Iran" = "Iran, Islamic Rep.",
"Congo (Kinshasa)" = "Congo, Dem. Rep.",
"Swaziland" = "Swaziland",
"Gambia" = "Gambia",
"Egypt" = "Egypt, Arab Rep.",
"Syria" = "Syrian Arab Republic",
"Yemen" = "Yemen, Rep.")
# Filter only countries in happiness dataset
happ_attr2019 <-
full_join(happ_attr2019, pop_ests2018, by = "country") %>%
filter(!is.na(overall_rank))
# Compute average attribute scores for each attribute
attr_scores2019 <- happ_attr2019 %>%
group_by(attr) %>%
summarise(mean_attr_score = mean(attr_score))
# Insert average attribute scores in df
happ_attr2019 <- full_join(happ_attr2019, attr_scores2019, by = "attr")
happ_attr2019_plot <- ggplot(data = happ_attr2019,
aes(x = 1:nrow(happ_attr2019), # x: number of rows in dataset
y = attr_score)) +
geom_point(aes(
colour = region,
alpha = 0.8,
size = pop_total,
label = country,
position = "jitter"
)) +
scale_colour_brewer(palette = "Paired") +
# Remove x-axis title, lable and ticks
theme(axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank()) +
facet_wrap(~ attr,
scales = "free_y", # rescale each attribute score
ncol = 3,
nrow = 2,
strip.position = "bottom"
) +
geom_line(aes(y = mean_attr_score, # Add average attribute
x = 1:nrow(happ_attr2019),
group = attr),
colour = "black",
alpha = 0.7,
linetype = "dashed") +
labs(y = "Attribute Scores") +
theme(legend.position = "none",
panel.background = element_rect(fill = "light grey")
)
happ_attr2019_plot
# Interactive map
# ggplotly(happ_attr2019_plot, tooltip = c("colour","label", "y", "size"))
